import path from 'path';
import { MonorepoConfig } from '../types';
import { writeFile } from '../utils/file-system';

export async function generateToolConfigs(
  projectPath: string,
  config: MonorepoConfig
): Promise<void> {
  // Generate .gitignore
  const gitignoreContent = generateGitignore();
  await writeFile(path.join(projectPath, '.gitignore'), gitignoreContent);

  // Generate .eslintrc.js
  if (config.tools.some(tool => tool.name === 'eslint' && tool.enabled)) {
    const eslintContent = generateEslintConfig();
    await writeFile(path.join(projectPath, '.eslintrc.js'), eslintContent);
  }

  // Generate .prettierrc
  if (config.tools.some(tool => tool.name === 'prettier' && tool.enabled)) {
    const prettierContent = generatePrettierConfig();
    await writeFile(path.join(projectPath, '.prettierrc'), prettierContent);
  }

  // Generate .husky configuration
  if (config.tools.some(tool => tool.name === 'husky' && tool.enabled)) {
    await generateHuskyConfigs(projectPath, config);
  }

  // Generate changesets configuration
  if (config.tools.some(tool => tool.name === 'changesets' && tool.enabled)) {
    await generateChangesetsConfig(projectPath, config);
  }

  // Generate environment files
  await generateEnvFiles(projectPath, config);

  // Generate additional tool configurations
  await generateAdditionalToolConfigs(projectPath, config);
}

function generateGitignore(): string {
  return `# Dependencies
node_modules/
.pnp
.pnp.js

# Testing
coverage/

# Production
build/
dist/
.next/
out/

# Environment files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Dependency directories
jspm_packages/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test
.env.production

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next

# Nuxt.js build / generate output
.nuxt
dist

# Storybook build outputs
.out
.storybook-out

# Temporary folders
tmp/
temp/

# Editor directories and files
.vscode/*
!.vscode/extensions.json
!.vscode/settings.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Logs
logs
*.log

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Turbo
.turbo

# Docker
.dockerignore

# Database
*.db
*.sqlite

# Misc
*.bak
*.tmp
*.temp
`;
}

function generateEslintConfig(): string {
  return `module.exports = {
  root: true,
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 2020,
    sourceType: 'module',
    ecmaFeatures: {
      jsx: true,
    },
  },
  settings: {
    react: {
      version: 'detect',
    },
  },
  env: {
    browser: true,
    amd: true,
    node: true,
  },
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  plugins: ['@typescript-eslint'],
  rules: {
    'prettier/prettier': ['error', {}, { usePrettierrc: true }],
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'warn',
    'no-console': 'off',
    '@typescript-eslint/no-unused-vars': 'error',
  },
};
`;
}

function generatePrettierConfig(): string {
  return `{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false,
  "arrowParens": "avoid",
  "endOfLine": "lf",
  "bracketSpacing": true,
  "jsxBracketSameLine": false,
  "proseWrap": "preserve"
}
`;
}

async function generateHuskyConfigs(projectPath: string, config: MonorepoConfig): Promise<void> {
  // Create pre-commit hook
  const preCommitContent = `#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

pnpm lint-staged
`;
  await writeFile(path.join(projectPath, '.husky', 'pre-commit'), preCommitContent);

  // Create commit-msg hook
  const commitMsgContent = `#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

pnpm commitlint --edit $1
`;
  await writeFile(path.join(projectPath, '.husky', 'commit-msg'), commitMsgContent);

  // Create .lintstagedrc.json
  const lintStagedContent = JSON.stringify(
    {
      '*.{ts,tsx,js,jsx}': ['eslint --fix', 'prettier --write'],
      '*.{json,md,yml,yaml}': ['prettier --write'],
    },
    null,
    2
  );
  await writeFile(path.join(projectPath, '.lintstagedrc.json'), lintStagedContent);

  // Create commitlint.config.js
  const commitlintContent = `module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'type-enum': [
      2,
      'always',
      [
        'feat',
        'fix',
        'docs',
        'style',
        'refactor',
        'test',
        'chore',
        'revert',
      ],
    ],
  },
};
`;
  await writeFile(path.join(projectPath, 'commitlint.config.js'), commitlintContent);
}

async function generateChangesetsConfig(
  projectPath: string,
  config: MonorepoConfig
): Promise<void> {
  // Create .changeset/config.json
  const changesetConfig = JSON.stringify(
    {
      $schema: 'https://unpkg.com/@changesets/config@2.3.0/schema.json',
      changelog: '@changesets/cli/changelog',
      commit: false,
      fixed: [],
      linked: [],
      access: 'restricted',
      baseBranch: 'main',
      updateInternalDependencies: 'patch',
      ignore: [],
    },
    null,
    2
  );
  await writeFile(path.join(projectPath, '.changeset', 'config.json'), changesetConfig);

  // Create .changeset/README.md
  const changesetReadme = `# Changesets

Hello and welcome! This folder has been automatically generated by \`@changesets/cli\`, a build tool that works with multi-package repos, or single-package repos to help you version and publish your code. You can find the full documentation for it [in our repository](https://github.com/changesets/changesets)

We have a quick list of common questions to get you started engaging with this project in [our documentation](https://github.com/changesets/changesets/blob/main/docs/common-questions.md)
`;
  await writeFile(path.join(projectPath, '.changeset', 'README.md'), changesetReadme);
}

async function generateEnvFiles(projectPath: string, config: MonorepoConfig): Promise<void> {
  // Generate .env.example
  const envExample = `# Environment Variables

# Application
NODE_ENV=development
PORT=3000

# Database
DATABASE_URL=postgresql://postgres:password@localhost:5432/monorepo

# Redis
REDIS_URL=redis://localhost:6379

# JWT
JWT_SECRET=your-jwt-secret-here

# API Keys
API_KEY=your-api-key-here

# External Services
EXTERNAL_SERVICE_URL=https://api.example.com
EXTERNAL_SERVICE_KEY=your-service-key-here
`;
  await writeFile(path.join(projectPath, '.env.example'), envExample);

  // Generate .env.local for development
  const envLocal = `# Local Development Environment Variables

NODE_ENV=development
PORT=3000

# Database
DATABASE_URL=postgresql://postgres:password@localhost:5432/monorepo_dev

# Redis
REDIS_URL=redis://localhost:6379

# JWT
JWT_SECRET=dev-jwt-secret

# Development specific
DEBUG=true
LOG_LEVEL=debug
`;
  await writeFile(path.join(projectPath, '.env.local'), envLocal);
}

async function generateAdditionalToolConfigs(
  projectPath: string,
  config: MonorepoConfig
): Promise<void> {
  // Generate VS Code settings
  const vscodeSettings = JSON.stringify(
    {
      'editor.defaultFormatter': 'esbenp.prettier-vscode',
      'editor.formatOnSave': true,
      'editor.codeActionsOnSave': {
        'source.fixAll.eslint': true,
      },
      'typescript.preferences.importModuleSpecifier': 'relative',
      'typescript.updateImportsOnFileMove.enabled': 'always',
      'files.exclude': {
        '**/node_modules': true,
        '**/dist': true,
        '**/.next': true,
        '**/build': true,
      },
      'search.exclude': {
        '**/node_modules': true,
        '**/dist': true,
        '**/.next': true,
        '**/build': true,
        '**/coverage': true,
      },
    },
    null,
    2
  );
  await writeFile(path.join(projectPath, '.vscode', 'settings.json'), vscodeSettings);

  // Generate VS Code extensions
  const vscodeExtensions = JSON.stringify(
    {
      recommendations: [
        'dbaeumer.vscode-eslint',
        'esbenp.prettier-vscode',
        'bradlc.vscode-tailwindcss',
        'ms-vscode.vscode-typescript-next',
        'ms-vscode.vscode-json',
        'redhat.vscode-yaml',
        'ms-vscode.vscode-docker',
        'github.copilot',
        'github.copilot-chat',
      ],
    },
    null,
    2
  );
  await writeFile(path.join(projectPath, '.vscode', 'extensions.json'), vscodeExtensions);

  // Generate launch.json for debugging
  const launchConfig = JSON.stringify(
    {
      version: '0.2.0',
      configurations: [
        {
          name: 'Next.js: debug server-side',
          type: 'node-terminal',
          request: 'launch',
          command: 'cd apps/corporate-website && npm run dev',
        },
        {
          name: 'Next.js: debug client-side',
          type: 'chrome',
          request: 'launch',
          url: 'http://localhost:3000',
        },
        {
          name: 'API Service: debug',
          type: 'node',
          request: 'launch',
          runtimeExecutable: 'node',
          runtimeArgs: ['--inspect', 'dist/index.js'],
          cwd: '${workspaceFolder}/services/api-gateway',
        },
      ],
    },
    null,
    2
  );
  await writeFile(path.join(projectPath, '.vscode', 'launch.json'), launchConfig);
}
